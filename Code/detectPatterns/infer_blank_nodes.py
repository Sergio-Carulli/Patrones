# Dictionary with the possible predicates inside a restriction
restrictions = {
    'owl:allValuesFrom':'',
    'owl:cardinality':'',
    'owl:hasSelf':'',
    'owl:hasValue':'',
    'owl:maxCardinality':'',
    'owl:maxQualifiedCardinality':'',
    'owl:minCardinality':'',
    'owl:minQualifiedCardinality':'',
    'owl:onClass':'',
    'owl:onDataRange':'',
    'owl:onProperties':'',
    'owl:onProperty':'',
    'owl:qualifiedCardinality':'',
    'owl:someValuesFrom':''
}

# Dictionary with the posible facets inside a datatype restriction
facets = {
    'xsd:minInclusive':'',
    'xsd:maxInclusive':'',
    'xsd:minExclusive':'',
    'xsd:maxExclusive':'',
    'xsd:minLength':'',
    'xsd:maxLength':'',
    'xsd:length':'',
    'xsd:pattern':'',
    'xsd:langRange':''
}

# This function receive as parameter two mutable objects (two lists).
# All modifications to a mutable object are applied directly to the object (instead of creating a new object).
# Therefore, changes made to the list in this class are also applied in the other class.
# A structure is written as a tree in its corresponding file, where the number of '  |' is the deep of a tree node.
# This structure has been parsed as a list where each line is stored as a different item.
# Moreover, each structure is generated by this program and have the same number of lines in both files.
# This function infers the types of terms that have been detected as "Blank node" within a structure.
def iterate_structure_blank_nodes(structure_name, structure_type):
    # Get the number of items in the list
    structure_len = len(structure_name)
    # This variable store the position of the list (skip the first three lines)
    i = 3
    # This variable store the type of the term which is on top of the structure
    top_type = structure_type[2].strip()

    # Iterate the structure
    while i < structure_len:
        # Read a line of the structure
        line = structure_name[i]
        # Get the deep of the line (the number of "  |")
        deep = line.count('  |')

        # Does the line represents the beginning of a blank node?
        if 'Blank node' in line:
            # Infer the "Blank node" types
            infer_blank_node(i, structure_name, structure_type, structure_len, deep, top_type)
            # Get the next line
            i += 1

        else:
            # Get the next line
            i += 1

# Function to infer the "Blank node" types within a structure
def infer_blank_node(i, structure_name, structure_type, structure_len, res_deep, top_type):

    # Is there at least another line in the structure?
    if i + 1 < structure_len:
        # Read the next line of the structure
        line = structure_name[i + 1]
        # Get the deep of the line and the substring (the number of "  |" and the substring after the last "   |")
        deep, substring = get_deep_and_substring(line)

        # Is the line outside the blank node?
        if deep <= res_deep:
            # This should not happens
            return
        
        # Does the next line represent an inverse property?
        elif 'owl:inverseOf' in substring:
            # Infers that the "Blank node" type is a "rdfs:Description"
            structure_name[i] = structure_name[i].replace('Blank node', 'rdfs:Description')
            structure_type[i] = structure_type[i].replace('Blank node', 'rdfs:Description')

        # Does the next line represent a datatype restriction?
        elif substring in facets:
            # Infers that the "Blank node" type is a "rdfs:Description"
            structure_name[i] = structure_name[i].replace('Blank node', 'rdfs:Description')
            structure_type[i] = structure_type[i].replace('Blank node', 'rdfs:Description')
        
        # Does the line represent the begining of a complement?
        elif 'owl:complementOf' in substring:
            # Infers that the "Blank node" type is an "owl:Class"
            structure_name[i] = structure_name[i].replace('Blank node', 'owl:Class')
            structure_type[i] = structure_type[i].replace('Blank node', 'owl:Class')

        # Does the line represent the begining of a union, intersection or enumeration?
        elif 'owl:unionOf' in substring or 'owl:intersectionOf' in substring or 'owl:oneOf' in substring:
            # Read the previous line of the structure
            previous_line = structure_name[i - 1]

            # Does the previous line represent a class axiom?
            if 'rdfs:subClassOf' in previous_line or 'owl:equivalentClass' in previous_line:
                # Infers that the "Blank node" type is the same type as the term which is on top of the structure
                structure_name[i] = structure_name[i].replace('Blank node', top_type)
                structure_type[i] = structure_type[i].replace('Blank node', top_type)
            
            elif 'owl:onClass' in previous_line:
                # Infers that the "Blank node" type is an "owl:Class"
                structure_name[i] = structure_name[i].replace('Blank node', 'owl:Class')
                structure_type[i] = structure_type[i].replace('Blank node', 'owl:Class')
            
            elif 'owl:onDataRange' in previous_line:
                # Infers that the "Blank node" type is an "rdfs:Datatype"
                structure_name[i] = structure_name[i].replace('Blank node', 'rdfs:Datatype')
                structure_type[i] = structure_type[i].replace('Blank node', 'rdfs:Datatype')

            else:
                structure_name[i] = structure_name[i].replace('Blank node', top_type)
                structure_type[i] = structure_type[i].replace('Blank node', top_type)
            """if 'owl:someValuesFrom' in substring or 'owl:allValuesFrom' in substring:
                # In this case the type of the term depends on the type of the property within the restriction
                # Infers that the "Blank node" type is an "owl:Class" or "rdfs:Datatype"
                structure_name[i] = structure_name[i].replace('Blank node', top_type)
                structure_type[i] = structure_type[i].replace('Blank node', top_type)"""
        
        # Does the line represent the begining of a restriction?
        elif substring in restrictions:
            # Infers that the "Blank node" type is an "owl:Restriction"
            structure_name[i] = structure_name[i].replace('Blank node', 'owl:Restriction')
            structure_type[i] = structure_type[i].replace('Blank node', 'owl:Restriction')

        # Does the line represent the begining of a data range?
        elif 'owl:onDatatype' in substring or 'owl:withRestrictions' in substring or 'owl:datatypeComplementOf':
            # Infers that the "Blank node" type is an "rdfs:Datatype"
            structure_name[i] = structure_name[i].replace('Blank node', 'rdfs:Datatype')
            structure_type[i] = structure_type[i].replace('Blank node', 'rdfs:Datatype')

# Function to calculate the deep of a structure line.
# The deep is represented by the number of times '|' appears in a line.
# Moreover, it gets the substring after the last '|'.
def get_deep_and_substring(line):
    # Variable to store the line deep
    deep = 0
    # Variable to store the substring after the last '|'
    substring = ''

    # Iterate the position and each character of the string
    for i, char in enumerate(line):

        # Does the char represent ' '?
        if char == ' ':
            # This means there is a '|' ahead
            continue

        # Does the char represent '|'?
        elif char == '|':
            # Increase the line deep
            deep += 1

        else:
            # In this case the term has been reached and the line deep has been calculated
            substring = line[i:]
            break

    # Return the line deep and the substring (removing the '\n')
    return deep, substring.strip()